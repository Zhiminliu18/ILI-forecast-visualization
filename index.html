<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ILI-forecast-visualization</title>
    <!-- 先加载 moment.js -->
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <!-- 再加载 Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- 最后加载日期适配器 -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #controlPanel {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #controlPanel label {
            margin-right: 5px;
        }
        #controlPanel select, #controlPanel input {
            padding: 5px;
            margin-right: 10px;
        }
        #controlPanel button {
            padding: 5px 10px;
            background-color: #4bc0c0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #controlPanel button:hover {
            background-color: #3a9d9d;
        }
        #chartContainer {
            width: 80%;
            max-width: 800px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="controlPanel">
        <label for="areaSelect">Choose area:</label>
        <select id="areaSelect"></select>
        <label for="yearSelect">Choose year:</label>
        <select id="yearSelect"></select>
        <label for="weekSelect">Choose flu week:</label>
        <select id="weekSelect"></select>
        <button onclick="prevWeek()">Last week</button>
        <button onclick="nextWeek()">Next week</button>
        <button onclick="updateChart()">Update prediction</button>
    </div>
    <div id="chartContainer">
        <canvas id="iliChart"></canvas>
    </div>

    <script>
        // 全局变量，用于存储加载的数据
        let iliData = [];
        let trueData = [];
        let chart;
        let yearWeekMap = {}; // 声明为全局变量
        let availableAreas = []; // 新增：存储所有可用地区

        const areaSelect = document.getElementById('areaSelect');
        const yearSelect = document.getElementById('yearSelect');
        const weekSelect = document.getElementById('weekSelect');
        const ctx = document.getElementById('iliChart').getContext('2d');

        // 异步加载数据并初始化
        async function initialize() {
            try {
                const response = await fetch('data.json');
                if (!response.ok) {
                    throw new Error(`HTTP错误! 状态码: ${response.status}`);
                }
                iliData = await response.json();

                // 初始化地区、年份和周数选择器
                yearWeekMap = {};
                availableAreas = [...new Set(iliData.map(item => item.area))].sort();
                availableAreas.forEach(area => {
                    areaSelect.add(new Option(area, area));
                });
                areaSelect.value = availableAreas[0];

                iliData.forEach(item => {
                    const date = moment(item.original_date);
                    const year = date.isoWeekYear();
                    const week = date.isoWeek();
                    if (!yearWeekMap[year]) yearWeekMap[year] = new Set();
                    yearWeekMap[year].add(week);
                });

                const availableYears = Object.keys(yearWeekMap).map(Number).sort();
                availableYears.forEach(year => {
                    yearSelect.add(new Option(year, year));
                });
                yearSelect.value = availableYears[0];
                updateWeekOptions();
                computeTrueData();

                // 添加事件监听器
                areaSelect.addEventListener('change', () => {
                    computeTrueData();
                    updateChart();
                });
                yearSelect.addEventListener('change', () => {
                    updateWeekOptions();
                    computeTrueData();
                    updateChart();
                });
            } catch (error) {
                console.error("加载数据失败:", error);
                alert(`数据加载失败: ${error.message}`);
            }
        }

        function updateWeekOptions() {
            const selectedYear = parseInt(yearSelect.value);
            weekSelect.innerHTML = '';
            const weeks = Array.from(yearWeekMap[selectedYear]).sort((a, b) => a - b);
            weeks.forEach(week => {
                weekSelect.add(new Option(week, week));
            });
            weekSelect.value = weeks[0];
        }

        function computeTrueData() {
            const selectedArea = areaSelect.value;
            let selectedYear = parseInt(yearSelect.value);
            const selectedWeek = parseInt(weekSelect.value);
            const startDate = moment(getStartDate(selectedYear, selectedWeek));
            selectedYear = moment(startDate).year();

            // 根据 startDate 的月份动态定义时间范围
            let start, end;
            if (startDate.month() >= 8) { // 9月及以后（月份从0开始计数）
                start = moment(startDate).year(selectedYear).month(8).date(1).startOf('day'); // 当年9月1日
                end = moment(startDate).year(selectedYear + 1).month(8).endOf('month').endOf('day'); // 下一年9月30日
            } else { // 1-8月
                start = moment(startDate).year(selectedYear - 1).month(8).date(1).startOf('day'); // 上一年9月1日
                end = moment(startDate).year(selectedYear).month(8).endOf('month').endOf('day'); // 当年9月30日
            }

            const tTrue = iliData.filter(item => {
                const date = moment(item.date);
                return date >= start && date < end && item.area === selectedArea;
            }).reduce((acc, item) => {
                const key = item.date;
                if (!acc[key]) acc[key] = { date: item.date, true: item.true };
                return acc;
            }, {});

            trueData = Object.values(tTrue).sort((a, b) => new Date(a.date) - new Date(b.date));
        }

        initialize();

        function getStartDate(year, week) {
            return moment()
                .isoWeekYear(year)
                .isoWeek(week)
                .startOf('week')      // 先定位到本周第一天（默认周一）
                .add(7, 'days')       // 再加6天到周日
                .format("YYYY-MM-DDTHH:mm:ss");
        }

        function prevWeek() {
            const selectedYear = parseInt(yearSelect.value);
            let currentWeek = parseInt(weekSelect.value);
            let weeks = Array.from(yearWeekMap[selectedYear]).sort((a, b) => a - b);
            let index = weeks.indexOf(currentWeek);

            if (index > 0) {
                weekSelect.value = weeks[index - 1];
                computeTrueData();
            } else {
                const prevYear = selectedYear - 1;
                if (yearWeekMap[prevYear]) {
                    yearSelect.value = prevYear;
                    updateWeekOptions();
                    weeks = Array.from(yearWeekMap[prevYear]).sort((a, b) => a - b);
                    weekSelect.value = weeks[weeks.length - 1];
                    computeTrueData();
                } else {
                    return; // 无上一年
                }
            }
            updateChart();
        }

        function nextWeek() {
            const selectedYear = parseInt(yearSelect.value);
            let currentWeek = parseInt(weekSelect.value);
            let weeks = Array.from(yearWeekMap[selectedYear]).sort((a, b) => a - b);
            let index = weeks.indexOf(currentWeek);

            if (index < weeks.length - 1) {
                weekSelect.value = weeks[index + 1];
                computeTrueData();
            } else {
                const nextYear = selectedYear + 1;
                if (yearWeekMap[nextYear]) {
                    yearSelect.value = nextYear;
                    updateWeekOptions();
                    weeks = Array.from(yearWeekMap[nextYear]).sort((a, b) => a - b);
                    weekSelect.value = weeks[0];
                    computeTrueData();
                } else {
                    return; // 无下一年
                }
            }
            updateChart();
        }

        function updateChart() {
            const selectedArea = areaSelect.value;
            const selectedYear = parseInt(yearSelect.value);
            const selectedWeek = parseInt(weekSelect.value);
 

            try {
                // 计算起始日期
                const startDate = moment(getStartDate(selectedYear, selectedWeek));

                // 筛选预测值数据（仅startDate当周，且匹配地区）
                const tPoint = iliData.filter(item => {
                    const originalDate = moment(item.original_date);
                    return originalDate.isSame(startDate, 'day') && item.area === selectedArea;
                });
                const methods = [...new Set(tPoint.map(item => item.method))];

                // 准备图表数据
                const datasets = [
                    {
                        label: 'True',
                        data: trueData.map(item => ({ x: item.date, y: item.true })),
                        borderColor: 'black',
                        backgroundColor: 'black',
                        pointStyle: 'circle',
                        fill: false
                    }
                ];

                const colors = ['red', 'blue', 'green', 'purple', 'orange'];

                // 辅助函数：将颜色关键字转换为 rgba 格式
                function colorToRgba(color, alpha = 1) {
                    const canvas = document.createElement('canvas').getContext('2d');
                    canvas.fillStyle = color;
                    const [r, g, b] = canvas.fillStyle.slice(1).match(/.{2}/g).map(hex => parseInt(hex, 16));
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }

                methods.forEach((method, i) => {
                    const methodData = tPoint
                        .filter(item => item.method === method)
                        .map(item => ({
                            x: item.date,
                            y: item.point,
                            q_2: item.q_2,
                            q_97: item.q_97
                        }))
                        .sort((a, b) => new Date(a.x) - new Date(b.x));

                    // 选择当前 method 的颜色
                    const methodColor = colors[i % colors.length];
                    const transparentColor = colorToRgba(methodColor, 0.2); // 透明度 0.2

                    // 添加下界
                    datasets.push({
                        label: `Lower Bound (${method})`,
                        data: methodData.map(item => ({ x: item.x, y: item.q_2 })),
                        borderColor: 'transparent',
                        backgroundColor: transparentColor,
                        fill: '+1', // 填充到下一个数据集
                        pointStyle: false,
                        showLine: false,
                        tension: 0,
                        order: 2 // 较低优先级，渲染在下层
                    });

                    // 添加上界
                    datasets.push({
                        label: `Upper Bound (${method})`,
                        data: methodData.map(item => ({ x: item.x, y: item.q_97 })),
                        borderColor: 'transparent torpedoes',
                        backgroundColor: transparentColor,
                        fill: '-1', // 填充到上一个数据集
                        pointStyle: false,
                        showLine: false,
                        tension: 0,
                        order: 2 // 较低优先级
                    });

                    // 添加预测点
                    datasets.push({
                        label: `Prediction (${method})`,
                        data: methodData.map(item => ({ x: item.x, y: item.y })),
                        borderColor: methodColor,
                        backgroundColor: methodColor,
                        pointStyle: 'cross',
                        borderDash: [5, 5],
                        fill: false,
                        order: 1 // 较高优先级，渲染在上层
                    });
                });

                // 更新图表
                if (chart) chart.destroy();
                chart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        animation: false, // 禁用动画
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    boxWidth: 15,
                                    padding: 20
                                }
                            },
                            title: {
                                display: true,
                                text: `ILI+ prediction for ${selectedArea} from ${startDate.format('YYYY-MM-DD')}`,
                                font: { size: 18 }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    parser: 'YYYY-MM-DDTHH:mm:ss',
                                    tooltipFormat: 'YYYY-MM-DD',
                                    unit: 'week',
                                    displayFormats: {
                                        week: 'YYYY-MM-DD'
                                    }
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxTicksLimit: 10,
                                    maxRotation: 45
                                },
                                title: { display: true, text: 'date' }
                            },
                            y: {
                                title: { display: true, text: 'ILI+' },
                                beginAtZero: true
                            }
                        }
                    }
                });
            } catch (e) {
                console.error('error:', e);
                alert('error, please select time range');
            }
        }

        // 初始渲染
        updateChart();
    </script>
</body>
</html>